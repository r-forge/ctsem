#' Plotting function for object class ctsemFit
#'
#' Ouputs mean trajectories, autoregression, and crossregression plots.
#' 
#' @param x ctsemFit object as generated by \code{\link{ctFit}}.
#' @param resolution Plot points between each unit of time.
#' @param wait If true, user is prompted to continue before plotting next graph.  If false, graphs are plotted one after another without waiting.
#' @param max.time Time scale on which to plot parameters.  If auto, parameters are plotted for full range of observed variables.
#' @param mean if TRUE, plot of means from 0 to max.time included in output.
#' @param withinVariance if TRUE, plot within subject variance / covariance.
#' @param betweenVariance if TRUE, plot between subject variance / covariance.
#' @param AR if TRUE, plot of autoregressive values from 0 to max.time included in output.
#' @param CR if TRUE, plot of cross regressive values from 0 to max.time included in output.
#' @param standardiseCR if TRUE (default), cross regression values are standardised based on estimated within subject variance.
#' @param xlab X axis label.
#' @param ylab Y axis label.
#' @param meansylim Vector of min and max limits for mean trajectory plot. 'auto' calculates automatically.
#' @param ... Other options passed to plot().
#' @return Nothing. Side-effect: plots graphs.
#' @export

plot.ctsemFit<-function(x,resolution=10,wait=TRUE,max.time="auto",mean=TRUE,
  withinVariance=TRUE,betweenVariance=TRUE,AR=TRUE,CR=TRUE,standardiseCR=TRUE,xlab="Time",
  meansylim='auto',ylab="Value",...){
  message("Plotting fit")
  ctfitobj<-x
  mxobj<-ctfitobj$mxobj

  ctsummary<-summary(ctfitobj)
  
  checkOpenMx('plot.ctsemFit')
  
  #read in values
  for(i in 1:length(ctsummary)){ #this loop reads in the specified continuous time model so the objects are available
    assign(names(ctsummary[i]),eval(parse(text = paste0("ctsummary","$",names(ctsummary[i])))))
  }    
  DRIFTlabels <- ctfitobj$mxobj$DRIFT$labels
  DIFFUSIONlabels <- ctfitobj$mxobj$DIFFUSION$labels
  latentNames<-ctfitobj$ctmodelobj$latentNames
  n.latent<-ctfitobj$ctmodelobj$n.latent
  n.manifest<-ctfitobj$ctmodelobj$n.manifest
  n.TIpred<-ctfitobj$ctmodelobj$n.TIpred
  n.TDpred<-ctfitobj$ctmodelobj$n.TDpred
  Tpoints<-ctfitobj$ctmodelobj$Tpoints
  stationary<-ctfitobj$ctfitargs$stationary
  if('T0MEANS' %in% stationary) T0MEANS<-ctfitobj$mxobj$T0MEANS$values
  if('T0VAR' %in% stationary) T0VAR<-ctfitobj$mxobj$T0VAR$values
  if('T0TRAITEFFECT' %in% stationary) T0TRAITEFFECT<-ctfitobj$mxobj$T0TRAITEFFECT$values
  if('T0TIPREDEFFECT' %in% stationary) T0TIPREDEFFECT<-ctfitobj$mxobj$T0TIPREDEFFECT$values
  
  if(max.time=="auto" & ctfitobj$ctfitargs$objective!='Kalman') max.time	<- max(rowSums(as.matrix(mxobj$data$observed[,paste0('dT',1:(Tpoints-1)),drop=FALSE]),na.rm=T)) 			# max time of plot 
  if(max.time=="auto" & ctfitobj$ctfitargs$objective=='Kalman') max.time  <- sum(mxobj$data$observed[,'dT1'],na.rm=T) 			# max time of plot 
  
  colourvector <- rainbow(ncol(DRIFT),v=.8) #set plot colours
  j<-matrix(seq(0,max.time,1/resolution)[-1],ncol=1) #time steps
  
  
  
  if(mean==TRUE){# 2. plot mean trend    
    means<-matrix(apply(j,1,function(x) OpenMx::expm(DRIFT*x) %*% T0MEANS+ 
        solve(DRIFT) %*% (OpenMx::expm(DRIFT*x)-diag(nrow(DRIFT))) %*% CINT),byrow=T,ncol=nrow(DRIFT))
    if(meansylim=='auto') meansylim<- c(min(means),max(means))
    
    
    plot(j, means[,1],   type = "l", xlab = xlab, ylab = ylab, 
      main="Process means",
      xlim=c(0,max.time), ylim=meansylim, lwd=2,col=colourvector[1])
    if(n.latent > 1) { 
      for(i in 2:n.latent){
        points(j, means[,i], type = "l", lwd=2,col=colourvector[i])
        legend("topright",legend=latentNames,text.col=colourvector,bty="n")
      }
    }
    
    
    if(wait==TRUE){
      message("Press [enter] to display next graph")
      readline()
    }
  } #end mean plot
    
    if(withinVariance==TRUE){ #plot within subject variance
      DRIFTHATCH<-(DRIFT %x% diag(n.latent) + diag(n.latent) %x% DRIFT)
      withinvar<-matrix(apply(j,1,function(x) matrix( 
        OpenMx::expm(DRIFT %x% x) %*% T0VAR  %*% t(OpenMx::expm(DRIFT %x% x)) + #initial variance
          matrix(solve(DRIFTHATCH) %*% ((OpenMx::expm(DRIFTHATCH %x% x)) -  diag(n.latent^2) ) %*% #diffusion process
              rvectorize(DIFFUSION),nrow=n.latent),nrow=n.latent)[row(diag(n.latent))>=col(diag(n.latent))]), 
        byrow=T,ncol=length(diag(n.latent)[row(diag(n.latent))>=col(diag(n.latent))]))
      
      colnames(withinvar)<-DIFFUSIONlabels[lower.tri(DIFFUSIONlabels,diag=T)]
      
      
      colourvector <- rainbow(length(DRIFT[upper.tri(DRIFT,diag=T)==T]),v=.8) 
      plot(j, withinvar[,1],   type = "l", xlab = xlab, ylab = ylab, 
        main="Within subject variance / covariance",
        xlim=c(0,max.time), ylim=c(min(withinvar),max(withinvar)), lwd=2,col=colourvector[1])
      if(n.latent > 1) { 
        for(i in 2:ncol(withinvar)){
          points(j, withinvar[,i], type = "l", lwd=2,col=colourvector[i])
          legend("topright",legend=colnames(withinvar),text.col=colourvector,bty="n")
        }
      }  
     
      
      if(wait==TRUE){
        message("Press [enter] to display next graph")
        readline()
      }
    } #end within variance plots
    
    if(betweenVariance==TRUE){ #plot between subject variance
      if(all(ctfitobj$mxobj$TRAITVAR$values == 0) & n.TIpred < 1) message('No between subject variance modelled - between subject variance trajectories not possible')
      if(any(ctfitobj$mxobj$TRAITVAR$values != 0) | n.TIpred > 0) {
      traitvariance<-0
      tipredvariance<-0
      

        if(any(ctfitobj$mxobj$TRAITVAR$values != 0)) {
        traitvariance<-matrix(apply(j,1,function(x) matrix( 
          (OpenMx::expm(DRIFT %x% x) %*% ( T0TRAITEFFECT) + (solve(DRIFT) %*% (OpenMx::expm(DRIFT %x% x) - diag(n.latent))))  %*% 
            TRAITVAR %*% t(
              (OpenMx::expm(DRIFT %x% x) %*% ( T0TRAITEFFECT) + (solve(DRIFT) %*% (OpenMx::expm(DRIFT %x% x) - diag(n.latent)))) )          
          ,nrow=n.latent)[row(diag(n.latent))>=col(diag(n.latent))]), 
          byrow=T,ncol=length(diag(n.latent)[row(diag(n.latent))>=col(diag(n.latent))]))
      }
      
      if(n.TIpred > 0) {
        tipredvariance<-matrix(apply(j,1,function(x) matrix( 
#           OpenMx::expm(DRIFT %x% x) %*% addedT0TIPREDVAR  %*% t(OpenMx::expm(DRIFT %x% x)) + #initial variance
            
            ( (OpenMx::expm(DRIFT %x% x)) %*% (T0TIPREDEFFECT ) + #T0 loading
            (solve(DRIFT) %*%(OpenMx::expm(DRIFT %x% x) - diag(n.latent)) %*% TIPREDEFFECT ) ) %*% #discrete loading
            TIPREDVAR %*% t( #variance of ti predictor
              ( (OpenMx::expm(DRIFT %x% x)) %*% (T0TIPREDEFFECT ) + #T0 loading
                  (solve(DRIFT) %*%(OpenMx::expm(DRIFT %x% x) - diag(n.latent)) %*% TIPREDEFFECT ) ) )          

          ,nrow=n.latent)[row(diag(n.latent))>=col(diag(n.latent))]), 
          byrow=T,ncol=length(diag(n.latent)[row(diag(n.latent))>=col(diag(n.latent))]))
      }
      betweenvariance<-traitvariance + tipredvariance
      
      colnames(betweenvariance)<-indexMatrix(dimension=n.latent,symmetrical=TRUE,unique=T,
        upper=FALSE,sep='_',indices=F,namesvector=latentNames)
      
        colourvector <- rainbow(length(DRIFT[upper.tri(DRIFT,diag=T)==T]),v=.8) 
        plot(j, betweenvariance[,1],   type = "l", xlab = xlab, ylab = ylab, 
          main="Between subject variance / covariance",
          xlim=c(0,max.time), ylim=c(min(betweenvariance),max(betweenvariance)), lwd=2,col=colourvector[1])
        if(n.latent > 1) { 
          for(i in 2:ncol(withinvar)){
            points(j, betweenvariance[,i], type = "l", lwd=2,col=colourvector[i])
            legend("topright",legend=colnames(betweenvariance),text.col=colourvector,bty="n")
          }
        }  
        
      
      if(wait==TRUE){
        message("Press [enter] to display next graph")
        readline()
      }
    }}#end between variance plots
    

  
  # 3. plot autoregressive/cross-lagged coefficients as function of time interval
  
  ar<- matrix(apply(j,1,function(x) c(diag(OpenMx::expm(DRIFT*x)))),ncol=nrow(DRIFT),byrow=T)
  
  if(standardiseCR==TRUE) standardiser<-suppressWarnings(rep(sqrt(diag(abs(asymDIFFUSION))),each=n.latent) / rep(diag(sqrt(abs(asymDIFFUSION))),times=n.latent))
  if(standardiseCR==FALSE) standardiser<-1

  cl<- matrix(apply(j,1,function(x) {
    c((OpenMx::expm(DRIFT*x)*standardiser)[row(DRIFT)!=col(DRIFT) & mxobj$DRIFT$free==TRUE])
  }
  ),ncol=length(DRIFT[row(DRIFT)!=col(DRIFT) & mxobj$DRIFT$free==TRUE]),byrow=T)
  
  arvars<-c(diag(DRIFTlabels))
  
  if(AR==TRUE){
    
    ylim <- c(0,1)
    if(max(ar) > 1) ylim[2] <- max(ar)
    if(min(ar) < 0) ylim[1] <- min(ar)
    
    #AR coefficient plot
    plot(j, ar[,1],   type = "l", xlab = xlab, ylab = ylab, 
      ylim=ylim, xlim=c(0,max.time), main="Autoregression",lwd=2,col=2,...)
    if(ncol(DRIFT)>1){ #if there is more than one AR parameter to plot
      for( i in 2:ncol(ar)){
        points(j, ar[,i], type = "l", lwd=2,col=colourvector[i],...)
      }
    }
    
    arnames <- paste0(arvars)
    
    legend("topright",legend=arnames,text.col=colourvector,bty="n")
  }
  
  
  #   if(!is.null(x$output$confidenceIntervals)) ci<-x$output$confidenceIntervals #if confidence intervals exist
  #   if(length(grep(paste0(arvars,collapse="|"),rownames(ci))) > 0) #if some matches for AR confidenceintervals found
  #   Alow <- ci[grep(paste0(arvars,collapse="|"),rownames(ci)),"lbound"] #extract
  #   Ahigh <- ci[grep(paste0(arvars,collapse="|"),rownames(ci)),"ubound"]
  
  
  if(CR==TRUE && ncol(cl)>1){   #CL coefficients
    if(wait==TRUE){
      message("Press [enter] to display next graph")
      readline()
    }
    if(standardiseCR==TRUE) CRtitle<-"Standardised crossregression"
    if(standardiseCR==FALSE) CRtitle<-"Unstandardised crossregression"
    colourvector <- rainbow(ncol(cl),v=.8) #set plot colours
    
    clvars<-DRIFTlabels[row(DRIFT)!=col(DRIFT) & mxobj$DRIFT$free==TRUE]
    #     if(length(clvars[is.na(as.numeric(clvars))]) > 0) {#if there is 1 or more estimated cross effects
    #       clvars <- clvars[is.na(as.numeric(clvars))] #remove fixed params from clvars list
    
    ylim <- c(-1,1)
    if(max(cl) > 1) ylim[2] <- max(cl)
    if(min(cl) < -1) ylim[1] <- min(cl)
    
    plot(j, cl[,1],   type = "l", xlab = xlab, ylab = ylab, 
      ylim=ylim, lwd=2,col=colourvector[1], main=CRtitle,...)
    
    for(i in 2:(ncol(cl))){
      points(j, cl[,i], type = "l", lwd=2,col=colourvector[i],...)
    }    
    legend("topright",legend=paste0(clvars),text.col=colourvector,bty="n")
  }
  
  
  
}

